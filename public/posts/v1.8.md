Today we are releasing Deno 1.8.0. TODO.

- [](#):
- [](#):
- [](#):

If you already have Deno installed you can upgrade to 1.8 by running
`deno upgrade`. If you are installing Deno for the first time, you can use one
of the methods listed below:

```shell
# Using Shell (macOS and Linux):
curl -fsSL https://deno.land/x/install/install.sh | sh

# Using PowerShell (Windows):
iwr https://deno.land/x/install/install.ps1 -useb | iex

# Using Homebrew (macOS):
brew install deno

# Using Scoop (Windows):
scoop install deno

# Using Chocolatey (Windows):
choco install deno
```

# New features and changes

## Experimental support for the WebGPU API

This release adds experimental support for the WebGPU API. The WebGPU API gives
developers a low level, high performance, cross architechture, and safe way to
access the GPU from JavaScript. It will be the effective successor to WebGL on
the Web. The API is still very much in-flux and has not yet been finalized, but
it is currently in development in Servo (Firefox), Chromium, and WebKit
(Safari), and now also in Deno.

This API gives you access to GPU rendering and general purpose GPU compute right
from within Deno. Once finished, stabilized, and unflagged, this will provide a
portable way to access GPU resources from web, server, and developer machine.

Here is a really basic example that just demonstrates accessing an attached GPU
device, and reading out the name and supported features:

```ts
const adapter = await navigator.gpu.requestAdapter();
if (!adapter) {
  console.error("No adapter found");
  Deno.exit(1);
}

console.log(`Found adapter: ${adapter.name}`);
const features = [...adapter.features.values()];
console.log(`Supported features: ${features.join(", ")}`);
```

Here is a little example that demonstrates the GPU rendering a simple red
triangle on a green background using a render shader:

```shell
$ deno run --unstable --allow-write=output.png https://raw.githubusercontent.com/crowlKats/webgpu-examples/main/hello-triangle/mod.ts
```

![A simple red triangle on a green background](/posts/v1.8/webgpu_triangle.png)

For more rendering examples visit this repository:
https://github.com/crowlKats/webgpu-examples

[Ry section about ML + Deno]

This the largest single feature addition since Deno 1.0. The final PR weighed in
at a whopping 15.5k lines of code, and took a whole 5 months to merge after
opening. Many thanks to [crowlKats](https://github.com/crowlKats) who led the
integration of WebGPU into Deno. We would also like to thank to all contributors
to  
the [wgpu](https://github.com/gfx-rs/wgpu) and gfx-rs projects that underpin the
WebGPU implementation in Deno. Special thanks also to
[kvark](https://github.com/kvark), the lead developer of wgpu and gfx-rs, and
editor for the WebGPU spec, for the great guidance while implementing the WebGPU
API.

## New `deno coverage` subcommand

This release expands our coverage infrastructure to add some great new
capabilities. The main change in this release is that coverage handling is now
split into coverage collection and coverage reporting.

Previously coverage collection and reporting would all happen in a single
subcommand, by specifying the `--coverage` flag when starting `deno test`. Now
the `--coverage` flag for `deno test` takes an argument - a path to a directory
where to store the collected profiles. This is the coverage collection. In a
second step you now call `deno coverage` with the path to the directory storing
the coverage profiles. This subcommand can either return a report as pretty text
output right on the console, or it can output an
[lcov](https://manpages.debian.org/testing/lcov/lcov.1.en.html) file (`--lcov`
flag) for use with tools like `genhtml`, coveralls.io, or codecov.io.

TODO: needs gif (luca)

## Import maps are now stable

Bartek

- Can now load from url
- Needs example
- Mention should be used for dependency rewriting, not for bare specifiers

## Auth token support for fetching modules

Not all code openly is available on the public internet. Previously Deno had no
capability to download code from a server that required authentication. In this
release we have added the ability for users to specify per domain auth tokens
that are used when fetching modules for the first time.

To do this the Deno CLI will look for an environment variable named
`DENO_AUTH_TOKENS` to determine what authentication tokens it should consider
using when requesting remote modules. The value of the environment variable is
in the format of a n number of tokens deliminated by a semi-colon (`;`) where
each token is in the format of `{token}@{hostname[:port]}`.

For example a single token for would look something like this:

```
DENO_AUTH_TOKENS=a1b2c3d4e5f6@deno.land
```

And multiple tokens would look like this:

```
DENO_AUTH_TOKENS=a1b2c3d4e5f6@deno.land;f1e2d3c4b5a6@example.com:8080
```

When Deno goes to fetch a remote module, where the hostname matches the hostname
of the remote module, Deno will set the `Authorization` header of the request to
the value of `Bearer {token}`. This allows the remote server to recognize that
the request is an authorized request tied to a specific authenticated user, and
provide access to the appropriate resources and modules on the server.

For a more detailed usage guide and instructions for configuring your
environment to pull from private GitHub repos,
[see the related manual entry](https://deno.land/manual/linking_to_external_code/private).

## `Intl` APIs now supported

Bartek

## Exit sanitizer for `Deno.test`

Bartek

- Needs example

## `Deno.permissions` APIs are now stable

Deno's security model is based on permissions. Currently these permissions can
only be granted when the application is started. This works well for most
scenarios, but in some cases it is a better user experience to request / revoke
permissions at runtime.

In Deno 1.8 there is now a stable API to `query`, `request`, and `revoke`
permissions. These APIs are contained in the `Deno.permissions` object. Here is
an example of how this works:

```ts
function homedir() {
  try {
    console.log(`Your home dir is: ${Deno.env.get("HOME")}`);
  } catch (err) {
    console.log(`Failed to get the home directory: ${err}`);
  }
}

// Try to get the home directory (this should fail, as no env permission yet).
homedir();

const { granted } = await Deno.permissions.request({ name: "env" });
if (granted) {
  console.log(`You have not granted the "env" permission.`);
} else {
  console.log(`You have not granted the "env" permission.`);
}

// Try to get the home directory (this should succeed if the user granted
// permissions above).
homedir();

await Deno.permissions.revoke({ name: "env" });

// Try to get the home directory (this should fail, as the permission was
// revoked).
homedir();
```

You can run this script yourself:
`deno run https://deno.land/posts/v1.8/permission_api.ts`.

TODO: add gif (luca)

## `Deno.link` API has been stabilized

Bartek

- Needs example

## More granular `Deno.metrics`

As Deno becomes more stable it is becoming more important have easy ways for
developers to instrument their applications. This starts at the lowest level, at
the runtime itself. In Deno all privileged operations in JS (the ones that go to
Rust), are done via a single central interface between JS and Rust. We call the
requests going over that interface "ops". For example, calling `Deno.open` would
invoke the `op_open_async` op to the privileged side, which would return the resource
id of the opened file (or an error).

More than two years ago, on Oct 11, 2018 we added a way for you to view metrics
for all of the ops between Rust and JS: `Deno.metrics`. This API currently
exposes the count of started, and completed sychronous and asynchronous ops, and
the amount of data that has been sent over the ops interface. So far this has
been limited to combined data for all of the different ops. There was no way to
figure out _which_ ops were invoked how many times, only all ops in general.

When running with `--unstable`, this release adds a new field to `Deno.metrics`
called `ops`. This field contains per op information about how often the API was
invoked and how much data has been transmitted over it. This allows for far more
granular instrumentation of the runtime.

Here is an example of this working:

```
$ deno --unstable
Deno 1.8.0
exit using ctrl+d or close()
> Deno.metrics().ops["op_open_async"]
undefined
> await Deno.open("./README.md")
File {}
> Deno.metrics().ops["op_open_async"]
{
  opsDispatched: 1,
  opsDispatchedSync: 0,
  opsDispatchedAsync: 1,
  opsDispatchedAsyncUnref: 0,
  opsCompleted: 1,
  opsCompletedSync: 0,
  opsCompletedAsync: 1,
  opsCompletedAsyncUnref: 0,
  bytesSentControl: 54,
  bytesSentData: 0,
  bytesReceived: 22
}
```

In an upcoming release this new information will be used by the async sanitizer
in `Deno.test` to give more actionable errors when an async op is not completed.
We have already seen this feature being used to instrument applications and pipe
the data into monitoring software:

![screenshot of a website with a table displaying the output of Deno.metrics](/posts/v1.8/per_op_metrics.png)

## JSON support for `deno fmt`

`deno fmt` can now format `.json` and `.jsonc` files. Just like with JS/TS, the
formatter will also format json and jsonc codeblocks inside of markdown files.

## IIFE bundle support for `Deno.emit`

Bartek

## `deno lsp` is now stable

We have been working on a replacement for our old editor integration for VS
Code, the Deno extension for the last few months. The old extension only worked
for VS Code, and the resolved types did not always match the ones in the Deno
CLI.

In Deno 1.6 we released `deno lsp` in canary - a builtin language server for
Deno. LSP allows us to provide editor integration to all LSP capable editors
from just a single codebase. The built in language server is built on the same
architecture as the rest of the Deno CLI - it thus provides TypeScript
diagnostics the same way as the rest of the CLI.

Two weeks ago, in Deno 1.7.5 we stabilized `deno lsp` and switched our
[offical VS Code extension](https://marketplace.visualstudio.com/items?itemName=denoland.vscode-deno)
to use it. So far we have gotten some great feedback, and will be working to
address all reported issues. If you are run into issues with the extension,
please reprort it on our issue tracker. We can not fix issues that we do not
know about.

In addition to the offical VS Code integration, more community integrations have
been created that are built on `deno lsp`:

- Vim with CoC: https://github.com/fannheyward/coc-deno
- Neovim: https://github.com/neovim/nvim-lspconfig/blob/master/CONFIG.md#denols
- Emacs: https://emacs-lsp.github.io/lsp-mode/page/lsp-deno/
- Kakoune:
  https://deno.land/manual/getting_started/setup_your_environment#example-for-kakoune
- Sublime:
  https://deno.land/manual/getting_started/setup_your_environment#example-for-sublime-text

## Update to TypeScript 4.2

Bartek
